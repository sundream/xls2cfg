#coding: utf-8
#@author sundream
#@date 2025-09-10

from XlsParser.XlsParser import XlsParser
from XlsParser.Type import Type
from XlsParser.Config import Config
import os

class Xls2CSharpParser(XlsParser):
    tablesTemplate = '''// auto generated by xls2cfg,do not edit!!!
using System;
using System.Collections.Generic;
using System.Reflection;

namespace Cfg {
    public enum Format
    {
        Json,
        Binary
    }

    public sealed class Tables {
        public static Format format = Format.Json;
        public static Tables Instance = null;
        public delegate byte[] LoadFromFileCallback(string filename);
        private LoadFromFileCallback loadFromFile = null;

        public T Get<K,T>(Dictionary<K,T> tables, K key) {
            T? table = default(T);
            if (!tables.TryGetValue(key,out table)) {
                return default(T);
            }
            return table;
        }

$tableFieldDefine
        private static T Deserialize<T>(byte[] data) {
            Type type = typeof(T);
            object obj = null;
            if (Tables.format == Format.Json) {
                var f = type.GetMethod("DeserializeFromJson",BindingFlags.Public | BindingFlags.Static);
                obj = f.Invoke(null,new object[] { data });
            }
            else {
                var f = type.GetMethod("DeserializeFromBinary",BindingFlags.Public | BindingFlags.Static);
                obj = f.Invoke(null, new object[] { data });
            }
            return (T)obj;
        }

        private static Dictionary<K, T> DeserializeTable<K, T>(byte[] data) {
            Type type = typeof(T);
            Dictionary<K, T> table;
            if (Tables.format == Format.Json) {
                var f = type.GetMethod("DeserializeTableFromJson",BindingFlags.Public | BindingFlags.Static);
                table = (Dictionary<K,T>)f.Invoke(null,new object[] {data });
            }
            else {
                var f = type.GetMethod("DeserializeTableFromBinary",BindingFlags.Public | BindingFlags.Static);
                table = (Dictionary<K,T>)f.Invoke(null, new object[] {data });
            }
            return table;
        }

        public Tables(LoadFromFileCallback loadFromFile) {
            Tables.Instance = this;
            this.loadFromFile = loadFromFile;
        }

        public void LoadAll(){
            var properties = this.GetType().GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.GetProperty);
            Object obj = null;
            for (int i = 0; i < properties.Length; i++) {
                var prop = properties[i];
                obj = prop.GetValue(this, null);
            }
        }
    }
}'''
    tableFieldDefineTemplate = '''        private Dictionary<$keyType,Cfg.$className> _$className;
        public Dictionary<$keyType,Cfg.$className> $className {
            get {
                if (this._$className == null) {
                    this._$className = Tables.DeserializeTable<$keyType,Cfg.$className>(this.loadFromFile("$filename"));
                }
                return this._$className;
            }
        }
'''
    tableFieldDefineTemplate2 = '''        private Cfg.$className _$className;
        public Cfg.$className $className {
            get {
                if (this._$className == null) {
                    this._$className = Tables.Deserialize<$className>(this.loadFromFile("$filename"));
                }
                return this._$className;
            }
        }
'''
    tableFieldInitTemplate = 3 * "    " + 'this._$className = Tables.DeserializeTable<$keyType,Cfg.$className>(this.loadFromFile("$filename"));'
    tableFieldInitTemplate2 = 3 * "    " + 'this._$className = Tables.Deserialize<$className>(this.loadFromFile("$filename"));'
    tableFieldDefine = []
    tableFieldInit = []

    classTemplate = '''// auto generated by xls2cfg,do not edit!!!
using SimpleJSON;
using System.Text;
using System.Collections.Generic;

namespace Cfg {
    // $classComment
    public sealed class $className {
$fieldDefine

        public $className () {}

        public $className (JSONNode jsonNode) {
$fieldInitFromJson
        }

        public $className (ByteStream bs) {
$fieldInitFromBinary
        }

        public override string ToString() {
            JSONObject jsonNode = new JSONObject();
$fieldToString
            return jsonNode.ToString();
        }

        public static $className DeserializeFromJson(byte[] data) {
            string str = Encoding.UTF8.GetString(data);
            JSONNode jsonNode = JSON.Parse(str);
            return new $className(jsonNode);
        }

        public static $className DeserializeFromBinary(byte[] data) {
            ByteStream bs = ByteStream.GetFromPool();
            bs.CopyBuffer(data);
            $className obj = new $className(bs);
            ByteStream.PutToPool(bs);
            return obj;
        }

        public static Dictionary<$keyType,$className> DeserializeTableFromJson(byte[] data) {
            string str = Encoding.UTF8.GetString(data);
            JSONNode jsonNode = JSON.Parse(str);
            Dictionary<$keyType,$className> table = new Dictionary<$keyType,$className>(jsonNode.Count);
            $className obj = null;
            foreach(JSONNode entry in jsonNode) {
$addToDict
            }
            return table;
        }

        public static Dictionary<$keyType,$className> DeserializeTableFromBinary(byte[] data) {
            ByteStream entry = ByteStream.GetFromPool();
            entry.CopyBuffer(data);
            int count = entry.ReadUInt16();
            Dictionary<$keyType,$className> table = new Dictionary<$keyType,$className>(count);
            $className obj = null;
            for (int i=0; i<count; i++) {
$addToDict
            }
            ByteStream.PutToPool(entry);
            return table;
        }
    }
}
'''
    classTemplate2 = '''// auto generated by xls2cfg,do not edit!!!
using SimpleJSON;
using System.Text;
using System.Collections.Generic;

namespace Cfg {
    // $classComment
    public sealed class $className {
$fieldDefine

        public $className () {}

        public $className (JSONNode jsonNode) {
$fieldInitFromJson
        }

        public $className (ByteStream bs) {
$fieldInitFromBinary
        }

        public override string ToString() {
            JSONObject jsonNode = new JSONObject();
$fieldToString
            return jsonNode.ToString();
        }

        public static $className DeserializeFromJson(byte[] data) {
            string str = Encoding.UTF8.GetString(data);
            JSONNode jsonNode = JSON.Parse(str);
            return new $className(jsonNode);
        }

        public static $className DeserializeFromBinary(byte[] data) {
            ByteStream bs = ByteStream.GetFromPool();
            bs.CopyBuffer(data);
            $className obj = new $className(bs);
            ByteStream.PutToPool(bs);
            return obj;
        }
    }
}
'''

    fieldDefineTemplate = 2 * XlsParser.indent + 'public readonly $fieldType $csFieldName;'
    fieldInitFromJsonTemplate = 3 * XlsParser.indent + 'this.$csFieldName = jsonNode["$fieldName"];'
    # fieldInitFromJsonTemplate = 3 * XlsParser.indent + 'this.$csFieldName = JSON.Parse<$fieldType>(jsonNode["$fieldName"]);'
    complexFieldInitFromJsonTemplate = 3 * XlsParser.indent + 'this.$csFieldName = JSON.Parse<$fieldType>(jsonNode["$fieldName"]);'

    fieldInitFromBinaryTemplate = 3 * XlsParser.indent + '$readCode'
    #fieldInitFromBinaryTemplate = 3 * XlsParser.indent + 'this.$csFieldName = bs.ReadValue<$fieldType>();'
    complexFieldInitFromBinaryTemplate = 3 * XlsParser.indent + 'this.$csFieldName = bs.ReadValue<$fieldType>();'

    fieldToStringTemplate = 3 * XlsParser.indent + 'jsonNode["$fieldName"] = this.$csFieldName;'
    complexFieldToStringTemplate = 3 * XlsParser.indent + 'jsonNode["$fieldName"] = this.$csFieldName.ToString();'
    addToDictTemplate = 4 * XlsParser.indent + 'obj = new $className(entry); table.Add(obj.$keyName,obj);'


    csharpTypes = {
        "bool" : "bool",
        "int8": "sbyte",
        "int16": "short",
        "int32" : "int",
        "int64" : "long",
        "uint8" : "byte",
        "uint16": "ushort",
        "uint32": "uint",
        "uint64": "ulong",
        "bigint": "decimal",
        "float" : "float",
        "double" : "double",
        "string" : "string",
        "i18nstring" : "string",
        "json" : "JSONNode",
        "bit32" : "int",
        "bit64" : "long",
        "list" : "List",
        "map" : "Dictionary",
    }

    readFuncs = {
        "bool" : "ReadBool",
        "int8": "ReadInt8",
        "int16": "ReadInt16",
        "int32" : "ReadInt32",
        "int64" : "ReadInt64",
        "uint8" : "ReadUInt8",
        "uint16": "ReadUInt16",
        "uint32": "ReadUInt32",
        "uint64": "ReadUInt64",
        "bigint": "ReadDecimal",
        "float" : "ReadFloat",
        "double" : "ReadDouble",
        "string" : "ReadString",
        "i18nstring" : "ReadString",
        "json" : "ReadJson",
        "bit32" : "ReadInt32",
        "bit64" : "ReadInt64",
        "list" : "ReadList<$valueType>",
        "map" : "ReadDictionary<$keyType,$valueType>",
    }

    codeComment = "//"
    extension = ".cs"

    fieldCommentTemplate = '%s $fieldComment' % codeComment

    def __init__(self,sheet,output):
        XlsParser.__init__(self,sheet,output)

    def parse(self):
        if self.isEmpty():
            return
        if self.sheet.singleton:
            self.parseSingletonSheet()
        else:
            self.parseSheet()

    def parseSingletonSheet(self):
        self.parseSheet()

    def parseSheet(self):
        filename = self.sheet.filename
        className = filename
        if Config.classNameFirstUpper:
            className = className[0].upper() + className[1:]
        if self.sheet.singleton:
            self.tableFieldDefine.append(self.formatTemplate(self.tableFieldDefineTemplate2,{
                "$className" : className,
                "$filename" : filename,
            }))
            self.tableFieldInit.append(self.formatTemplate(self.tableFieldInitTemplate2,{
                "$className" : className,
                "$filename" : filename,
            }))
        else:
            idField = self.type.getIdField()
            keyType = Xls2CSharpParser.getCSharpTypename(idField.type)
            self.tableFieldDefine.append(self.formatTemplate(self.tableFieldDefineTemplate,{
                "$keyType" : keyType,
                "$className" : className,
                "$filename" : filename,
            }))
            self.tableFieldInit.append(self.formatTemplate(self.tableFieldInitTemplate,{
                "$keyType" : keyType,
                "$className" : className,
                "$filename" : filename,
            }))

    @staticmethod
    def getCSharpTypename(typ):
        typename = typ.typename
        if typ.isClass():
            return typename
        if Xls2CSharpParser.csharpTypes[typename] is None:
            raise Exception("unknow typename: %s" % typename)
        typename = Xls2CSharpParser.csharpTypes[typename]
        if typename == "List":
            typename = "%s<%s>" % (typename,Xls2CSharpParser.getCSharpTypename(typ.valueType))
        elif typename == "Dictionary":
            typename = "%s<%s,%s>" % (typename,Xls2CSharpParser.getCSharpTypename(typ.keyType),Xls2CSharpParser.getCSharpTypename(typ.valueType))
        return typename

    @staticmethod
    def formatTemplate(template,kv):
        s = template
        for k,v in kv.items():
            s = s.replace(k,v)
        return s

    @staticmethod
    def getReadFunc(typ):
        typename = typ.typename
        readFunc = Xls2CSharpParser.readFuncs.get(typename)
        if typename == "list":
            valueType = Xls2CSharpParser.getCSharpTypename(typ.valueType)
            readFunc = Xls2CSharpParser.formatTemplate(readFunc,{
                "$valueType" : valueType,
            })
        elif typename == "map":
            keyType = Xls2CSharpParser.getCSharpTypename(typ.keyType)
            valueType = Xls2CSharpParser.getCSharpTypename(typ.valueType)
            readFunc = Xls2CSharpParser.formatTemplate(readFunc,{
                "$keyType" : keyType,
                "$valueType" : valueType,
            })
        elif readFunc is None:
            # class
            readFunc = Xls2CSharpParser.formatTemplate("ReadValue<$typename>",{
                "$typename" : typename,
            })
        return readFunc


    @classmethod
    def endParse(cls,output):
        cls.writeAllClass(output)
        data = Xls2CSharpParser.formatTemplate(Xls2CSharpParser.tablesTemplate,{
            "$tableFieldDefine" : "\n".join(Xls2CSharpParser.tableFieldDefine),
            #"$tableFieldInit" : "\n".join(Xls2CSharpParser.tableFieldInit),
        })
        filename = "Tables"
        print("write",output,filename)
        filename = os.path.join(output,filename + ".cs")
        parent_dir = os.path.dirname(filename)
        if parent_dir != "" and not os.path.isdir(parent_dir):
            os.makedirs(parent_dir)
        fd = open(filename,"wb")
        fd.write(data.encode())
        fd.close()

    @classmethod
    def writeClass(cls,typ,output):
        Parser = cls
        className = typ.typename
        fieldDefine = []
        fieldInitFromJson = []
        fieldInitFromBinary = []
        fieldToString = []
        for field in typ.fields:
            fieldType = field.type
            fieldName = field.name
            csFieldName = fieldName
            fieldTypename = fieldType.typename
            csFieldTypename = Parser.getCSharpTypename(fieldType)
            oneFieldDefine = Parser.formatTemplate(Parser.fieldDefineTemplate,{
                "$fieldType" : csFieldTypename,
                "$csFieldName" : csFieldName,
                "$fieldName" : fieldName,
            })
            fieldComment = field.comment
            fieldComment = Parser.formatTemplate(Parser.fieldCommentTemplate,{
                "$fieldComment" : fieldComment,
            })
            oneFieldDefine = "%-60s%s" % (oneFieldDefine,fieldComment)
            fieldDefine.append(oneFieldDefine)
            readFunc = Xls2CSharpParser.readFuncs.get(fieldTypename)
            if not readFunc:
                fieldInitFromJson.append(Parser.formatTemplate(Parser.complexFieldInitFromJsonTemplate,{
                    "$csFieldName" : csFieldName,
                    "$fieldName" : fieldName,
                    "$fieldType" : csFieldTypename,
                }))
                fieldInitFromBinary.append(Parser.formatTemplate(Parser.complexFieldInitFromBinaryTemplate,{
                    "$csFieldName" : csFieldName,
                    "$fieldName" : fieldName,
                    "$fieldType" : csFieldTypename,
                }))
                fieldToString.append(Parser.formatTemplate(Parser.complexFieldToStringTemplate,{
                    "$csFieldName" : csFieldName,
                    "$fieldName" : fieldName,
                }))
            else:
                readCode = None
                if fieldTypename == "list":
                    valueType = Xls2CSharpParser.getCSharpTypename(fieldType.valueType)
                    value_readFunc = Xls2CSharpParser.getReadFunc(fieldType.valueType)
                    readCode = '{int length = bs.ReadUInt8(); this.$csFieldName = new List<$valueType>(length); for (int i = 0; i < length; i++) { this.$csFieldName.Add(bs.$value_readFunc());}}'
                    readCode = Parser.formatTemplate(readCode,{
                        "$csFieldName" : csFieldName,
                        "$valueType" : valueType,
                        "$value_readFunc" : value_readFunc,
                    })
                elif fieldTypename == "map":
                    keyType = Xls2CSharpParser.getCSharpTypename(fieldType.keyType)
                    valueType = Xls2CSharpParser.getCSharpTypename(fieldType.valueType)
                    key_readFunc = Xls2CSharpParser.getReadFunc(fieldType.keyType)
                    value_readFunc = Xls2CSharpParser.getReadFunc(fieldType.valueType)
                    readCode = '{int length = bs.ReadUInt8(); this.$csFieldName = new Dictionary<$keyType,$valueType>(length); for (int i = 0; i < length; i++) { this.$csFieldName.Add(bs.$key_readFunc(),bs.$value_readFunc());}}'
                    readCode = Parser.formatTemplate(readCode,{
                        "$csFieldName" : csFieldName,
                        "$keyType" : keyType,
                        "$valueType" : valueType,
                        "$key_readFunc" : key_readFunc,
                        "$value_readFunc" : value_readFunc,
                    })
                else:
                    readCode = Parser.formatTemplate("this.$csFieldName = " + "bs." + readFunc + "();",{
                        "$csFieldName" : csFieldName,
                    })
                if fieldTypename == "bigint" or fieldTypename == "list" or fieldTypename == "map" or fieldType.isClass():
                    fieldInitFromJson.append(Parser.formatTemplate(Parser.complexFieldInitFromJsonTemplate,{
                        "$csFieldName" : csFieldName,
                        "$fieldName" : fieldName,
                        "$fieldType" : csFieldTypename,
                    }))
                    fieldToString.append(Parser.formatTemplate(Parser.complexFieldToStringTemplate,{
                        "$csFieldName" : csFieldName,
                        "$fieldName" : fieldName,
                    }))
                else:
                    fieldInitFromJson.append(Parser.formatTemplate(Parser.fieldInitFromJsonTemplate,{
                        "$csFieldName" : csFieldName,
                        "$fieldName" : fieldName,
                        "$fieldType" : csFieldTypename,
                    }))
                    fieldToString.append(Parser.formatTemplate(Parser.fieldToStringTemplate,{
                        "$csFieldName" : csFieldName,
                        "$fieldName" : fieldName,
                    }))
                fieldInitFromBinary.append(Parser.formatTemplate(Parser.fieldInitFromBinaryTemplate,{
                    "$csFieldName" : csFieldName,
                    "$fieldName" : fieldName,
                    "$fieldType" : csFieldTypename,
                    "$readCode" : readCode,
                }))
        classComment = typ.comment or ''
        idField = typ.getIdField()
        if idField:
            keyType = idField.type
            keyName = idField.name
            keyTypename = keyType.typename
            keyType = Parser.getCSharpTypename(keyType)
            if keyTypename == "int8" or keyTypename == "int16" or keyTypename == "int32" or keyTypename == "int64" or keyTypename == "uint8" or keyTypename == "uint16" or keyTypename == "uint32" or keyTypename == "uint64" or keyTypename == "bigint":
                addToDict = Parser.formatTemplate(Parser.addToDictTemplate,{
                    "$keyType" : keyType,
                    "$className" : className,
                    "$keyName" : keyName,
                })
            else:
                if keyTypename != "string" and keyTypename != "i18nstring":
                    raise Exception("invalid keyType,className=%s,keyType=%s" % (className,keyType))
                addToDict = Parser.formatTemplate(Parser.addToDictTemplate,{
                    "$keyType" : keyType,
                    "$className" : className,
                    "$keyName" : keyName,
                })


            classCode = Parser.formatTemplate(Parser.classTemplate,{
                "$classComment" : classComment,
                "$className" : className,
                "$fieldDefine" : "\n".join(fieldDefine),
                "$fieldInitFromJson" : "\n".join(fieldInitFromJson),
                "$fieldInitFromBinary" : "\n".join(fieldInitFromBinary),
                "$fieldToString" : "\n".join(fieldToString),

                "$keyType" : keyType,
                "$addToDict" : addToDict,
            })
        else:
            classCode = Parser.formatTemplate(Parser.classTemplate2,{
                "$classComment" : classComment,
                "$className" : className,
                "$fieldDefine" : "\n".join(fieldDefine),
                "$fieldInitFromJson" : "\n".join(fieldInitFromJson),
                "$fieldInitFromBinary" : "\n".join(fieldInitFromBinary),
                "$fieldToString" : "\n".join(fieldToString),
            })
        data = classCode
        filename = className
        filename = os.path.join(output,filename + ".cs")
        parentDir = os.path.dirname(filename)
        if parentDir != "" and not os.path.isdir(parentDir):
            os.makedirs(parentDir)
        fd = open(filename,"wb")
        fd.write(data.encode())
        fd.close()
